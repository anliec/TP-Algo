\documentclass[a4paper, 12pts]{article}

\usepackage[top=3.5cm, bottom=3.5cm, left=3cm, right=3cm]{geometry}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[francais]{babel}
\usepackage{textcomp}
\usepackage{listings}
\lstset{language=C++} 

%\usepackage{hyperref} %pour les liens internet

%\usepackage{graphicx} %pour les images
\title{TP2 C++}
\author{B3111: Edern HAUMONT et Nicolas SIX}
\date{Mercredi 11 novembre 2015}

%to define the subsubsubsection structure:
\input{subsubsubsection.tex}


%-----------------------------------------------------------------------------------------


\begin{document}

\begin{titlepage}

\maketitle

\end{titlepage}

%----------------------------------------------Title end

\tableofcontents

\pagebreak

%----------------------------------------------table of contents end

%==================================================================================================
%                                     Section: Introduction
%==================================================================================================

\section{Introduction}
\paragraph{}

\subsection{Choice of the data structure}
\paragraph{}
Our application must support 20 million events from 1500 sensors. Consequently, we chose not to store event themselves as they arrive. However, at the launch of our program, several static arrays of entire values are created. Their indexes correspond to the information used to anwer to the user querries, for instance the sensor number, the hour,etc. Their last dimension corresponds to a sensor color. So when an event is added, we just increment one cell in each array.

%==================================================================================================
%                                     Section: Clases
%==================================================================================================
\section{Classes}


%<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
%                                   DataHandler
%<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
\subsection{DataHandler}
\paragraph{}
All data additions and request are managed by the class DataHandler which contain itself the 4 data arrays.

%----------------------------------------------------------------------------------------
%                                  Constants
%----------------------------------------------------------------------------------------
\subsubsection{Constants}

\paragraph{}
	This class use differents constants, first there are one error code used when the trafic char is not one of the four expected: 'V','J','R','N'

\begin{lstlisting}
const unsigned int ERROR_INVALID_TRAFIC_UCHAR = 201;
\end{lstlisting}

\paragraph{}
	DataHandler also use constants to define the size of the arrays used to store all the datas.

\begin{lstlisting}
const int NUMBER_OF_COLORS = 4;
const int NUMBER_OF_SENSORS = 1500;
const int NUMBER_OF_MINUTES = 1440;
const int NUMBER_OF_HOURS = 24;
const int NUMBER_OF_DAYS = 7;
\end{lstlisting}

%----------------------------------------------------------------------------------------
%                                  Atributs
%----------------------------------------------------------------------------------------
\subsubsection{Atributs}
\paragraph{}
	To make our code more readable we decided to use the following type def in the DataHandler Class.
\begin{lstlisting}
typedef unsigned int uint;
\end{lstlisting}

\paragraph{}
	The atributs used in this class are the following:
\begin{lstlisting}
IdHash idHash;
uint sensors[NUMBER_OF_SENSORS][NUMBER_OF_COLORS];
uint days[NUMBER_OF_DAYS][NUMBER_OF_COLORS];
uint daysAndHours[NUMBER_OF_DAYS][NUMBER_OF_HOURS][NUMBER_OF_COLORS];
unsigned char *daysAndMin[NUMBER_OF_DAYS][NUMBER_OF_MINUTES][NUMBER_OF_COLORS];
\end{lstlisting}

\paragraph{}
	idHash is an instance of our IdHash class, which is detailled latter. It's an hash tab that we use to link the sensors id and the position in our static tabs.
	sensors, days, daysAndHours and daysAndMin are four static array used to store statistics which will be used in our stats methods. The fourth array is a four dimantion one with the last one, coreponding to the sensors id, is alocated using a new in the construtor.

%----------------------------------------------------------------------------------------
%                                  Public Methods
%----------------------------------------------------------------------------------------
\subsubsection{Public Methods}

\subsubsubsection{addData}
\begin{lstlisting}
int addData(const char &trafic,const uint &min,const uint &hours,\
	const uint &id,const uint &day7);
\end{lstlisting}
\paragraph{description:}
	Method used to update member arrays in corresponding cells. Complexity: O(1).
\paragraph{Contract:}
	The values given must be ritghtly build: min shoult be between 0 and 59, hours between 0 and 23 and day7 between 0, for monday, and 6, for sunday. To work properly trafic must be set to one of: 'V','J','R','N'.

\subsubsubsection{sensorStats}
\begin{lstlisting}
int sensorStats(uint id) const;
\end{lstlisting}
\paragraph{description:}
	Prints the sensor statistics for an id. Complexity: O(1).
\paragraph{Contract:}
	The id given in parameter must corespond to a sensors with an already added id else the stats will use the first added sensor. Print null stats if 0 corresponding event

\subsubsubsection{jamStats}
\begin{lstlisting}
int jamStats(uchar day7);
\end{lstlisting}
\paragraph{description:}
	prints jam statistics for a day. Complexity: O(1).
\paragraph{Contract:}
	day7 must be between 0 and 6 $(NUMBER\_OF\_DAYS-1)$. Print null stats if 0 corresponding event.
		
\subsubsubsection{dayStats}
\begin{lstlisting}
int dayStats(uchar day7);
\end{lstlisting}
\paragraph{description:}
	prints a week day statistics for a given day. Complexity: O(1).
\paragraph{Contract:}
	day7 must be between 0 and 6 $(NUMBER\_OF\_DAYS-1)$. Print null stats if 0 corresponding event
		
\subsubsubsection{optimum}
\begin{lstlisting}
int optimum(uchar day7, uint begginHours, uint endHours,\
		uint idTab[], uint tabSize);
\end{lstlisting}
\paragraph{description:}
	optimum look for the best departure time in a given interval. Complexity: $O(tabsize * (endHours-beginHours) )$.
\paragraph{Contract:}
	day7 must be between 0 and 6 $(NUMBER\_OF\_DAYS-1)$. begginHours and endHours must be between 0 and 23 with begginHours smaller than endHours. idTab must be an array of size tabSize filled with already added sensors' id (if an id is not added the first added sensors will be used).
	
	To compute the optimum departure time this methode consider that the time taken to go throuht a sensors is the most probable one at this time of the day acording to the added data. In case of equality on trafic information, the quiker will be used (optimistic).

%<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
%                                   IdHash
%<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
\subsection{IdHash}

\paragraph{}
This class makes the link between a sensor id of the user and indexes in data tables
It is a hashTable and its structure is an array.
It is not designed for more than 25000 ids.

%----------------------------------------------------------------------------------------
%                                  Constants
%----------------------------------------------------------------------------------------
\subsubsection{Constants}

\paragraph{}
	This Class use differents constants, most of them are related to the hash function.

\begin{lstlisting}
const int SIZE_OF_HASHTABLE = 5000;
//hash function parameters
const int PRIME_NUMBER = 7001;
const int A = 1;
const int B = 0;
\end{lstlisting}

%----------------------------------------------------------------------------------------
%                                  Atributs
%----------------------------------------------------------------------------------------
\subsubsection{Atributs}

\paragraph{}
	The private atributs used in this class are the following:
\begin{lstlisting}
unsigned * hashTable[SIZE_OF_HASHTABLE][2];
unsigned sizeOfHashList[SIZE_OF_HASHTABLE][2];
unsigned lastIdInTab;
\end{lstlisting}
\paragraph{}	
    hashTable is an array of two dimentions plus one last dynamic one. The first one is the hash array itself and correspond to the position given by the hash function. The segond one is there to have both the sensors id and the position on the program array. The last dimention is a way to handel case where the hash function give the same position to tow differents id.
    
    sizeOfHashList is an two dimentions array created to now the size and the used size of each dynamic part of hashTable.
    
    lastIdInTab keep the value of the last added position in order to just have to increment it for the next add.
    
    
%----------------------------------------------------------------------------------------
%                                  Public Methods
%----------------------------------------------------------------------------------------
\subsubsection{Public Methods}

\subsubsubsection{addId}
\begin{lstlisting}
unsigned addId(const unsigned & id);
\end{lstlisting}
\paragraph{description:}
	add the user id to the hash table if not already in and returns an array position used by the program.
\paragraph{Contract:}
	id in int range.
\subsubsubsection{getTabId}
\begin{lstlisting}
unsigned getTabId(const unsigned & id) const;
\end{lstlisting}
\paragraph{description:}
	returns the array position used by the program corresponding to a sensor id called by the the user.
\paragraph{Contract:}
	id in unsigned int range if id is not in the hash tab, return 0.
	
%----------------------------------------------------------------------------------------
%                                  Hash function
%----------------------------------------------------------------------------------------
\subsubsection{Hash function}

\paragraph{}
	In order to have a good repartition of our datas on the hash tab we use the clasical:
\begin{equation}
	hash(id)=(A*id+B)\%PRIME\_NUMBER)\%SIZE\_OF\_HASHTABLE
\end{equation}	
	With $A$, $B$, $PRIME\_NUMBER$ and $SIZE\_OF\_HASHTABLE$ the constants defined in the constents section.
	
	This function can be improved with random $A$ and $B$ generated at the begining of the execution in order to forgive a data set to always be the worst one.

%==================================================================================================
%                                     Section: tests
%==================================================================================================
\input{Tests.tex}


\end{document}





